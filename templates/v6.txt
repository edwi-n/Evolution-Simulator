<!DOCTYPE html>
<html>

<head>
  <style>
    body {
      background-color: grey;
      color: white
    }
  </style>
</head>

<body>
  <h1 id="title">Evolution Simulator</h1>
  <div id="simulation-main">
    <div id="simulation-info"></div>
    <canvas id="simulation-grid" width="1000" height="1000"></canvas>
    <!-- <div id="simulation-grid"></div> -->
    <div id="simulation-progress"></div>
    <div id="selected-organism-info"></div>
  </div>
  </div>
</body>

</html>

<script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script>
  var data = JSON.parse('{{data | tojson | safe}}')
  const canvas = document.getElementById("simulation-grid")
  const ctx = canvas.getContext("2d")
  var iteration = 1
  var j = 0
  ctx.fillStyle = "white"
  ctx.fillRect(0, 0, 1000, 1000)

  chain = fetch("/get").then((response) => {
    console.log(iteration)
    iteration += 1
    return response.json()
  }).then((dat) => {
    data.movement = data.movement.concat(dat.movement)
    data.organisms = data.organisms.concat(dat.organisms)
    return 9
    // while (j < data.movement.length) {
    //   j += 1;
    // }
    // return j
  });

  function resetGrid() {
    var grid = []
    var row = []
    for (let l = 0; l < 100; l++) {
      row.push(" ")
    }
    for (let l = 0; l < 100; l++) {
      grid.push(row)
    }
    return grid
  }

  function displayGrid(grid) {
    console.clear()
    display = ""
    for (let l = 0; l < 100; l++) {
      row = ""
      for (let k = 0; k < 100; k++) {
        row += grid[l][k]
      }
      row += "\n"
      display += row
    }
    console.log(display)
  }

  function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  async function wait() {
    return new Promise(resolve => setTimeout(async function () {
      resolve("resolved")
    }, 0))
  }

  var grid = resetGrid();
  var startIndex = 0

  for (let i = 0; i < 100; i++) {
    chain = chain.then((a) => {
      iteration += 1
      return fetch("/get")
    }).then((response) => {
      return response.json();
    }).then((dat) => {
      data.movement = data.movement.concat(dat.movement)
      data.organisms = data.organisms.concat(dat.organisms)
      prev = {}
      // console.log(i, j, data.movement.length)
      // console.log(dat.movement)
      async function loop() {
        // while (j < data.movement.length) {
        setInterval(() => {
          if (j == data.movement.length) {
            return
          }
          if (data.movement[j][0] == -1) {
            ctx.fillRect(0, 0, 1000, 1000)
          } else {
            if (data.movement[j][0] in prev) {
              ctx.fillRect(prev[data.movement[j][0]][0] * 10, prev[data.movement[j][0]][1] * 10, 10, 10)
            }
            ctx.clearRect(data.movement[j][1][1] * 10, data.movement[j][1][0] * 10, 10, 10)
            prev[data.movement[j][0]] = [data.movement[j][1][1], [data.movement[j][1][0]]]
            // document.getElementById("simulation-progress").innerHTML = i
            // await new Promise(r => setTimeout(r, 0.0001));

          }
          // await new Promise(r => setTimeout(r, 0.0001));
          j += 1
        }, Number.MAX_SAFE_INTEGER);
        // await new Promise(r => setTimeout(r, 0));
        // const waitt = await new Promise(resolve => setTimeout(async function () {
        //   resolve("resolved")
        // }, 2))
        // }
        console.log(j)
      }
      return loop()
      // function loop() {
      //   return new Promise(resolve => setTimeout(async function () {
      //     // if (j < data.movement.length) {
      //     //   if (data.movement[j][0] == -1) {
      //     //     ctx.fillRect(0, 0, 1000, 1000)
      //     //     // grid = resetGrid()
      //     //   } else {
      //     //     if (data.movement[j][0] in prev) {
      //     //       ctx.fillRect(prev[data.movement[j][0]][0] * 10, prev[data.movement[j][0]][1] * 10, 10, 10)
      //     //       // grid[prev[data.movement[j][0]][0]][prev[data.movement[j][0]][1]] = ' '
      //     //     }
      //     //     ctx.clearRect(data.movement[j][1][1] * 10, data.movement[j][1][0] * 10, 10, 10)
      //     //     // grid[data.movement[j][1][1]][data.movement[j][1][0]] = 'x'
      //     //     prev[data.movement[j][0]] = [data.movement[j][1][1], [data.movement[j][1][0]]]
      //     //     document.getElementById("simulation-progress").innerHTML = i
      //     //   }
      //     //   j += 1;
      //     //   const wait = await loop();
      //     //   resolve("resolved")
      //     // } else {
      //     //   console.log("Returning")
      //     //   resolve("resolved")
      //     // }
      //   }, 0))
      // }
      // async function start() {
      //   console.log("Enter")
      //   startIndex = j
      //   const wait = await loop()
      //   console.log(wait)
      //   console.log("Finished")
      // }
      // return start()
    }
    )
    console.log(i);
  }
  chain.then(() => {
    console.log(j);
    console.log(data)
  })
</script>